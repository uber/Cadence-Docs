"use strict";(self.webpackChunkcadence=self.webpackChunkcadence||[]).push([[5861],{6082:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"go-client/retries","title":"Activity and workflow retries","description":"Activitiesworkflow can fail due to various intermediate conditions. In those cases, we want","source":"@site/docs/05-go-client/06-retries.md","sourceDirName":"05-go-client","slug":"/go-client/retries","permalink":"/Cadence-Docs/docs/go-client/retries","draft":false,"unlisted":false,"editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/docs/05-go-client/06-retries.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"layout":"default","title":"Activity and workflow retries","permalink":"/docs/go-client/retries"},"sidebar":"docsSidebar","previous":{"title":"Child workflows","permalink":"/Cadence-Docs/docs/go-client/child-workflows"},"next":{"title":"Error handling","permalink":"/Cadence-Docs/docs/go-client/error-handling"}}');var r=i(4848),o=i(8453);const s={layout:"default",title:"Activity and workflow retries",permalink:"/docs/go-client/retries"},a="Activity and workflow retries",c={},l=[];function d(e){const t={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"activity-and-workflow-retries",children:"Activity and workflow retries"})}),"\n",(0,r.jsx)(t.p,{children:"Activities and workflows can fail due to various intermediate conditions. In those cases, we want\nto retry the failed activity or child workflow or even the parent workflow. This can be achieved\nby supplying an optional retry policy. A retry policy looks like the following:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'// RetryPolicy defines the retry policy.\nRetryPolicy struct {\n    // Backoff interval for the first retry. If coefficient is 1.0 then it is used for all retries.\n    // Required, no default value.\n    InitialInterval time.Duration\n\n    // Coefficient used to calculate the next retry backoff interval.\n    // The next retry interval is previous interval multiplied by this coefficient.\n    // Must be 1 or larger. Default is 2.0.\n    BackoffCoefficient float64\n\n    // Maximum backoff interval between retries. Exponential backoff leads to interval increase.\n    // This value is the cap of the interval. Default is 100x of initial interval.\n    MaximumInterval time.Duration\n\n    // Maximum time to retry. Either ExpirationInterval or MaximumAttempts is required.\n    // When exceeded the retries stop even if maximum retries is not reached yet.\n    // First (non-retry) attempt is unaffected by this field and is guaranteed to run \n    // for the entirety of the workflow timeout duration (ExecutionStartToCloseTimeoutSeconds).\n    ExpirationInterval time.Duration\n\n    // Maximum number of attempts. When exceeded the retries stop even if not expired yet.\n    // If not set or set to 0, it means unlimited, and relies on ExpirationInterval to stop.\n    // Either MaximumAttempts or ExpirationInterval is required.\n    MaximumAttempts int32\n\n    // Non-Retriable errors. This is optional. Cadence server will stop retry if error reason matches this list.\n    // Error reason for custom error is specified when your activity/workflow returns cadence.NewCustomError(reason).\n    // Error reason for panic error is "cadenceInternal:Panic".\n    // Error reason for any other error is "cadenceInternal:Generic".\n    // Error reason for timeouts is: "cadenceInternal:Timeout TIMEOUT_TYPE". TIMEOUT_TYPE could be START_TO_CLOSE or HEARTBEAT.\n    // Note that cancellation is not a failure, so it won\'t be retried.\n    NonRetriableErrorReasons []string\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["To enable retry, supply a custom retry policy to ",(0,r.jsx)(t.code,{children:"ActivityOptions"})," or ",(0,r.jsx)(t.code,{children:"ChildWorkflowOptions"}),"\nwhen you execute them."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"expiration := time.Minute * 10\nretryPolicy := &cadence.RetryPolicy{\n    InitialInterval:    time.Second,\n    BackoffCoefficient: 2,\n    MaximumInterval:    expiration,\n    ExpirationInterval: time.Minute * 10,\n    MaximumAttempts:    5,\n}\nao := workflow.ActivityOptions{\n    ScheduleToStartTimeout: expiration,\n    StartToCloseTimeout:    expiration,\n    HeartbeatTimeout:       time.Second * 30,\n    RetryPolicy:            retryPolicy, // Enable retry.\n}\nctx = workflow.WithActivityOptions(ctx, ao)\nactivityFuture := workflow.ExecuteActivity(ctx, SampleActivity, params)\n"})}),"\n",(0,r.jsx)(t.p,{children:"If activity heartbeat its progress before it failed, the retry attempt will contain the progress\nso activity implementation could resume from failed progress like:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"func SampleActivity(ctx context.Context, inputArg InputParams) error {\n    startIdx := inputArg.StartIndex\n    if activity.HasHeartbeatDetails(ctx) {\n        // Recover from finished progress.\n        var finishedIndex int\n        if err := activity.GetHeartbeatDetails(ctx, &finishedIndex); err == nil {\n            startIdx = finishedIndex + 1 // Start from next one.\n        }\n    }\n\n    // Normal activity logic...\n    for i:=startIdx; i<inputArg.EndIdx; i++ {\n        // Code for processing item i goes here...\n        activity.RecordHeartbeat(ctx, i) // Report progress.\n    }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Like retry for an activity, you need to supply a retry policy for ",(0,r.jsx)(t.code,{children:"ChildWorkflowOptions"})," to enable\nretry for a child workflow. To enable retry for a parent workflow, supply a retry policy when\nyou start a workflow via ",(0,r.jsx)(t.code,{children:"StartWorkflowOptions"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["There are some subtle changes to workflow's history events when ",(0,r.jsx)(t.code,{children:"RetryPolicy"})," is used.\nFor an activity with ",(0,r.jsx)(t.code,{children:"RetryPolicy"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"ActivityTaskScheduledEvent"})," will have extended ",(0,r.jsx)(t.code,{children:"ScheduleToStartTimeout"})," and ",(0,r.jsx)(t.code,{children:"ScheduleToCloseTimeout"}),". These two timeouts\nwill be overwritten by the server to be as long as the retry policy's ",(0,r.jsx)(t.code,{children:"ExpirationInterval"}),". If the ",(0,r.jsx)(t.code,{children:"ExpirationInterval"}),"\nis not specified, it will be overwritten to the workflow's timeout."]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"ActivityTaskStartedEvent"})," will not show up in history until the activity is completed or failed with no more retry.\nThis is to avoid recording the ",(0,r.jsx)(t.code,{children:"ActivityTaskStarted"})," event but later it failed and retried. Using the ",(0,r.jsx)(t.code,{children:"DescribeWorkflowExecution"}),"\nAPI will return the ",(0,r.jsx)(t.code,{children:"PendingActivityInfo"})," and it will contain ",(0,r.jsx)(t.code,{children:"attemptCount"})," if it is retrying."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["For a workflow with ",(0,r.jsx)(t.code,{children:"RetryPolicy"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["If a workflow failed and needs to retry, the workflow_execution will be closed with a ",(0,r.jsx)(t.code,{children:"ContinueAsNew"})," event. The event\nwill have the ",(0,r.jsx)(t.code,{children:"ContinueAsNewInitiator"})," set to ",(0,r.jsx)(t.code,{children:"RetryPolicy"})," and the new ",(0,r.jsx)(t.code,{children:"RunID"})," for the next retry attempt."]}),"\n",(0,r.jsxs)(t.li,{children:["The new attempt will be created immediately. But the first decision_task won't be scheduled until the backoff duration\nwhich is also recorded in the new run's ",(0,r.jsx)(t.code,{children:"WorkflowExecutionStartedEventAttributes"})," event as ",(0,r.jsx)(t.code,{children:"firstDecisionTaskBackoffSeconds"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>a});var n=i(6540);const r={},o=n.createContext(r);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);