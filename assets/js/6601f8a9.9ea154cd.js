"use strict";(self.webpackChunkcadence=self.webpackChunkcadence||[]).push([[7998],{3276:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"java-client/child-workflows","title":"Child workflows","description":"Besidesactivitiesworkflowworkflow.","source":"@site/docs/04-java-client/13-child-workflows.md","sourceDirName":"04-java-client","slug":"/java-client/child-workflows","permalink":"/Cadence-Docs/docs/java-client/child-workflows","draft":false,"unlisted":false,"editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/docs/04-java-client/13-child-workflows.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"layout":"default","title":"Child workflows","permalink":"/docs/java-client/child-workflows"},"sidebar":"docsSidebar","previous":{"title":"Retries","permalink":"/Cadence-Docs/docs/java-client/retries"},"next":{"title":"Exception Handling","permalink":"/Cadence-Docs/docs/java-client/exception-handling"}}');var i=t(4848),l=t(8453);const r={layout:"default",title:"Child workflows",permalink:"/docs/java-client/child-workflows"},c="Child workflows",s={},a=[];function d(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"child-workflows",children:"Child workflows"})}),"\n",(0,i.jsx)(n.p,{children:"Besides activities, a workflow can also orchestrate other workflows."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"workflow.ExecuteChildWorkflow"})," enables the scheduling of other workflows from within a workflow's\nimplementation. The parent workflow has the ability to monitor and impact the lifecycle of the child\nworkflow, similar to the way it does for an activity that it invoked."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public static class GreetingWorkflowImpl implements GreetingWorkflow {\n\n  @Override\n  public String getGreeting(String name) {\n    // Workflows are stateful. So a new stub must be created for each new child.\n    GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n    // This is a non blocking call that returns immediately.\n    // Use child.composeGreeting("Hello", name) to call synchronously.\n    Promise<String> greeting = Async.function(child::composeGreeting, "Hello", name);\n    // Do something else here.\n    return greeting.get(); // blocks waiting for the child to complete.\n  }\n\n  // This example shows how parent workflow return right after starting a child workflow,\n  // and let the child run itself.\n  private String demoAsyncChildRun(String name) {\n    GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n    // non blocking call that initiated child workflow\n    Async.function(child::composeGreeting, "Hello", name);\n    // instead of using greeting.get() to block till child complete,\n    // sometimes we just want to return parent immediately and keep child running\n    Promise<WorkflowExecution> childPromise = Workflow.getWorkflowExecution(child);\n    childPromise.get(); // block until child started,\n    // otherwise child may not start because parent complete first.\n    return "let child run, parent just return";\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Workflow.newChildWorkflowStub"})," returns a client-side stub that implements a child workflow interface.\nIt takes a child workflow type and optional child workflow options as arguments. Workflow options may be needed to override\nthe timeouts and task_list if they differ from the ones defined in the ",(0,i.jsx)(n.code,{children:"@WorkflowMethod"})," annotation or parent workflow."]}),"\n",(0,i.jsxs)(n.p,{children:["The first call to the child workflow stub must always be to a method annotated with ",(0,i.jsx)(n.code,{children:"@WorkflowMethod"}),". Similar to activities, a call\ncan be made synchronous or asynchronous by using ",(0,i.jsx)(n.code,{children:"Async#function"})," or ",(0,i.jsx)(n.code,{children:"Async#procedure"}),". The synchronous call blocks until a child workflow completes. The asynchronous call\nreturns a ",(0,i.jsx)(n.code,{children:"Promise"})," that can be used to wait for the completion. After an async call returns the stub, it can be used to send signals to the child\nby calling methods annotated with ",(0,i.jsx)(n.code,{children:"@SignalMethod"}),". Querying a child workflow by calling methods annotated with ",(0,i.jsx)(n.code,{children:"@QueryMethod"}),"\nfrom within workflow code is not supported. However, queries can be done from activities\nusing the provided ",(0,i.jsx)(n.code,{children:"WorkflowClient"})," stub."]}),"\n",(0,i.jsx)(n.p,{children:"Running two children in parallel:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public static class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n\n        // Workflows are stateful, so a new stub must be created for each new child.\n        GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting1 = Async.function(child1::composeGreeting, "Hello", name);\n\n        // Both children will run concurrently.\n        GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting2 = Async.function(child2::composeGreeting, "Bye", name);\n\n        // Do something else here.\n        ...\n        return "First: " + greeting1.get() + ", second: " + greeting2.get();\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To send a signal to a child, call a method annotated with ",(0,i.jsx)(n.code,{children:"@SignalMethod"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public interface GreetingChild {\n    @WorkflowMethod\n    String composeGreeting(String greeting, String name);\n\n    @SignalMethod\n    void updateName(String name);\n}\n\npublic static class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n        GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting = Async.function(child::composeGreeting, "Hello", name);\n        child.updateName("Cadence");\n        return greeting.get();\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Calling methods annotated with ",(0,i.jsx)(n.code,{children:"@QueryMethod"})," is not allowed from within workflow code."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var o=t(6540);const i={},l=o.createContext(i);function r(e){const n=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);