"use strict";(self.webpackChunkcadence=self.webpackChunkcadence||[]).push([[7180],{3112:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var o=n(3315),i=n(4848),r=n(8453);const s={title:"Non-deterministic errors, replayers and shadowers",date:new Date("2023-08-27T00:00:00.000Z"),authors:"chopincode",tags:["deep-dive","testing"]},c=void 0,a={authorsImageUrls:[void 0]},l=[];function d(e){const t={code:"code",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"It is conceivable that developers constantly update their Cadence workflow code based upon new business use cases and needs. However,\nthe definition of a Cadence workflow must be deterministic because behind the scenes cadence uses event sourcing to construct\nthe workflow state by replaying the historical events stored for this specific workflow. Introducing components that are not compatible\nwith an existing running workflow will yield to non-deterministic errors and sometimes developers find it tricky to debug. Consider the\nfollowing workflow that executes two activities."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'func SampleWorkflow(ctx workflow.Context, data string) (string, error) {\n    ao := workflow.ActivityOptions{\n        ScheduleToStartTimeout: time.Minute,\n        StartToCloseTimeout:    time.Minute,\n    }\n    ctx = workflow.WithActivityOptions(ctx, ao)\n    var result1 string\n    err := workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n    if err != nil {\n        return "", err\n    }\n    var result2 string\n    err = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\n    return result2, err\n}\n\n'})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var o=n(6540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}},3315:e=>{e.exports=JSON.parse('{"permalink":"/Cadence-Docs/blog/2023/08/28/nondeterministic-errors-replayers-shadowers","editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/blog/2023-08-28-nondeterministic-errors-replayers-shadowers.md","source":"@site/blog/2023-08-28-nondeterministic-errors-replayers-shadowers.md","title":"Non-deterministic errors, replayers and shadowers","description":"It is conceivable that developers constantly update their Cadence workflow code based upon new business use cases and needs. However,","date":"2023-08-27T00:00:00.000Z","tags":[{"inline":false,"label":"Deep Dives","permalink":"/Cadence-Docs/blog/tags/deep-dives","description":"Deep Dives tag description"},{"inline":false,"label":"Testing","permalink":"/Cadence-Docs/blog/tags/testing","description":"Testing tag description"}],"readingTime":2.305,"hasTruncateMarker":true,"authors":[{"name":"Chris Qin","title":"Applications Developer @ Uber","url":"https://www.linkedin.com/in/chrisqin0610/","page":{"permalink":"/Cadence-Docs/blog/authors/chopincode"},"socials":{"linkedin":"https://www.linkedin.com/in/chrisqin0610/","github":"https://github.com/chopincode"},"imageURL":"https://github.com/chopincode.png","key":"chopincode"}],"frontMatter":{"title":"Non-deterministic errors, replayers and shadowers","date":"2023-08-27T00:00:00.000Z","authors":"chopincode","tags":["deep-dive","testing"]},"unlisted":false,"prevItem":{"title":"Cadence Community Spotlight Update - August 2023","permalink":"/Cadence-Docs/blog/2023/08/31/community-spotlight-august-2023"},"nextItem":{"title":"Cadence Community Spotlight Update - July 2023","permalink":"/Cadence-Docs/blog/2023/07/31/community-spotlight-july-2023"}}')}}]);