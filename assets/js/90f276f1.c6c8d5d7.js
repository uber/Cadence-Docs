"use strict";(self.webpackChunkcadence=self.webpackChunkcadence||[]).push([[4960],{8926:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"go-client/continue-as-new","title":"Continue as new","description":"Workflows: that need to rerun periodically could naively be implemented as a big for loop with","source":"@site/docs/05-go-client/09-continue-as-new.md","sourceDirName":"05-go-client","slug":"/go-client/continue-as-new","permalink":"/docs/go-client/continue-as-new","draft":false,"unlisted":false,"editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/docs/05-go-client/09-continue-as-new.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"layout":"default","title":"Continue as new","permalink":"/docs/go-client/continue-as-new"},"sidebar":"docsSidebar","previous":{"title":"Signals","permalink":"/docs/go-client/signals"},"next":{"title":"Side effect","permalink":"/docs/go-client/side-effect"}}');var r=t(4848),i=t(8453);const s={layout:"default",title:"Continue as new",permalink:"/docs/go-client/continue-as-new"},c="Continue as new",l={},a=[];function d(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"continue-as-new",children:"Continue as new"})}),"\n",(0,r.jsxs)(n.p,{children:["Workflows that need to rerun periodically could naively be implemented as a big ",(0,r.jsx)(n.strong,{children:"for"})," loop with\na sleep where the entire logic of the workflow is inside the body of the ",(0,r.jsx)(n.strong,{children:"for"})," loop. The problem\nwith this approach is that the history for that workflow will keep growing to a point where it\nreaches the maximum size enforced by the service."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ContinueAsNew"})," is the low level construct that enables implementing such workflows without the\nrisk of failures down the road. The operation atomically completes the current execution and starts\na new execution of the workflow with the same ",(0,r.jsx)(n.strong,{children:"workflow_ID"}),". The new execution will not carry\nover any history from the old execution. To trigger this behavior, the workflow function should\nterminate by returning the special ",(0,r.jsx)(n.strong,{children:"ContinueAsNewError"})," error:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func SimpleWorkflow(workflow.Context ctx, value string) error {\n    ...\n    return workflow.NewContinueAsNewError(ctx, SimpleWorkflow, value)\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var o=t(6540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);