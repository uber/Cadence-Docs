"use strict";(self.webpackChunkcadence=self.webpackChunkcadence||[]).push([[6156],{887:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"go-client/execute-activity","title":"Executing activities","description":"The primary responsibility of a implementation is to scheduleactivities: for execution. The","source":"@site/docs/05-go-client/04-execute-activity.md","sourceDirName":"05-go-client","slug":"/go-client/execute-activity","permalink":"/docs/go-client/execute-activity","draft":false,"unlisted":false,"editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/docs/05-go-client/04-execute-activity.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"layout":"default","title":"Executing activities","permalink":"/docs/go-client/execute-activity"},"sidebar":"docsSidebar","previous":{"title":"Activity overview","permalink":"/docs/go-client/activities"},"next":{"title":"Child workflows","permalink":"/docs/go-client/child-workflows"}}');var c=i(4848),o=i(8453);const a={layout:"default",title:"Executing activities",permalink:"/docs/go-client/execute-activity"},s="Executing activities",r={},l=[{value:"Activity options",id:"activity-options",level:2},{value:"Activity timeouts",id:"activity-timeouts",level:2},{value:"ExecuteActivity call",id:"executeactivity-call",level:2}];function d(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(t.header,{children:(0,c.jsx)(t.h1,{id:"executing-activities",children:"Executing activities"})}),"\n",(0,c.jsxs)(t.p,{children:["The primary responsibility of a workflow implementation is to schedule activities for execution. The\nmost straightforward way to do this is via the library method ",(0,c.jsx)(t.code,{children:"workflow.ExecuteActivity"}),". The following\nsample code demonstrates making this call:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-go",children:'ao := cadence.ActivityOptions{\n    TaskList:               "sampleTaskList",\n    ScheduleToCloseTimeout: time.Second * 60,\n    ScheduleToStartTimeout: time.Second * 60,\n    StartToCloseTimeout:    time.Second * 60,\n    HeartbeatTimeout:       time.Second * 10,\n    WaitForCancellation:    false,\n}\nctx = cadence.WithActivityOptions(ctx, ao)\n\nfuture := workflow.ExecuteActivity(ctx, SimpleActivity, value)\nvar result string\nif err := future.Get(ctx, &result); err != nil {\n    return err\n}\n'})}),"\n",(0,c.jsx)(t.p,{children:"Let's take a look at each component of this call."}),"\n",(0,c.jsx)(t.h2,{id:"activity-options",children:"Activity options"}),"\n",(0,c.jsxs)(t.p,{children:["Before calling ",(0,c.jsx)(t.code,{children:"workflow.ExecuteActivity()"}),", you must configure ",(0,c.jsx)(t.code,{children:"ActivityOptions"})," for the\ninvocation. These options customize various execution timeouts, and are passed in by creating a child\ncontext from the initial context and overwriting the desired values. The child context is then passed\ninto the ",(0,c.jsx)(t.code,{children:"workflow.ExecuteActivity()"})," call. If multiple activities are sharing the same option\nvalues, then the same context instance can be used when calling ",(0,c.jsx)(t.code,{children:"workflow.ExecuteActivity()"}),"."]}),"\n",(0,c.jsx)(t.h2,{id:"activity-timeouts",children:"Activity timeouts"}),"\n",(0,c.jsxs)(t.p,{children:["There can be various kinds of timeouts associated with an activity. Cadence guarantees that activities\nare executed ",(0,c.jsx)(t.em,{children:"at most once"}),", so an activity either succeeds or fails with one of the following timeouts:"]}),"\n",(0,c.jsxs)(t.table,{children:[(0,c.jsx)(t.thead,{children:(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.th,{children:"Timeout"}),(0,c.jsx)(t.th,{children:"Description"})]})}),(0,c.jsxs)(t.tbody,{children:[(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"StartToCloseTimeout"})}),(0,c.jsx)(t.td,{children:"Maximum time that a worker can take to process a task after it has received the task."})]}),(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"ScheduleToStartTimeout"})}),(0,c.jsx)(t.td,{children:"Time a task can wait to be picked up by an activity_worker after a workflow schedules it. If there are no workers available to process this task for the specified duration, the task will time out."})]}),(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"ScheduleToCloseTimeout"})}),(0,c.jsxs)(t.td,{children:["Time a task can take to complete after it is scheduled by a workflow. This is usually greater than the sum of ",(0,c.jsx)(t.code,{children:"StartToClose"})," and ",(0,c.jsx)(t.code,{children:"ScheduleToStart"})," timeouts."]})]}),(0,c.jsxs)(t.tr,{children:[(0,c.jsx)(t.td,{children:(0,c.jsx)(t.code,{children:"HeartbeatTimeout"})}),(0,c.jsx)(t.td,{children:"If a task doesn't heartbeat to the Cadence service for this duration, it will be considered to have failed. This is useful for long-running tasks."})]})]})]}),"\n",(0,c.jsx)(t.h2,{id:"executeactivity-call",children:"ExecuteActivity call"}),"\n",(0,c.jsxs)(t.p,{children:["The first parameter in the call is the required ",(0,c.jsx)(t.code,{children:"cadence.Context"})," object. This type is a copy of\n",(0,c.jsx)(t.code,{children:"context.Context"})," with the ",(0,c.jsx)(t.code,{children:"Done()"})," method returning ",(0,c.jsx)(t.code,{children:"cadence.Channel"})," instead of the native Go ",(0,c.jsx)(t.code,{children:"chan"}),"."]}),"\n",(0,c.jsx)(t.p,{children:"The second parameter is the function that we registered as an activity function. This parameter can\nalso be a string representing the fully qualified name of the activity function. The benefit of passing\nin the actual function object is that the framework can validate activity parameters."}),"\n",(0,c.jsxs)(t.p,{children:["The remaining parameters are passed to the activity as part of the call. In our example, we have a\nsingle parameter: ",(0,c.jsx)(t.code,{children:"value"}),". This list of parameters must match the list of parameters declared by\nthe activity function. The Cadence client library will validate this."]}),"\n",(0,c.jsxs)(t.p,{children:["The method call returns immediately and returns a ",(0,c.jsx)(t.code,{children:"cadence.Future"}),". This allows you to execute more\ncode without having to wait for the scheduled activity to complete."]}),"\n",(0,c.jsxs)(t.p,{children:["When you are ready to process the results of the activity, call the ",(0,c.jsx)(t.code,{children:"Get()"})," method on the future\nobject returned. The parameters to this method are the ",(0,c.jsx)(t.code,{children:"ctx"})," object we passed to the\n",(0,c.jsx)(t.code,{children:"workflow.ExecuteActivity()"})," call and an output parameter that will receive the output of the\nactivity. The type of the output parameter must match the type of the return value declared by the\nactivity function. The ",(0,c.jsx)(t.code,{children:"Get()"})," method will block until the activity completes and results are\navailable."]}),"\n",(0,c.jsxs)(t.p,{children:["You can retrieve the result value returned by ",(0,c.jsx)(t.code,{children:"workflow.ExecuteActivity()"})," from the future and use\nit like any normal result from a synchronous function call. The following sample code demonstrates how\nyou can use the result if it is a string value:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-go",children:'var result string\nif err := future.Get(ctx1, &result); err != nil {\n    return err\n}\n\nswitch result {\ncase "apple":\n    // Do something.\ncase "banana":\n    // Do something.\ndefault:\n    return err\n}\n'})}),"\n",(0,c.jsxs)(t.p,{children:["In this example, we called the ",(0,c.jsx)(t.code,{children:"Get()"})," method on the returned future immediately after ",(0,c.jsx)(t.code,{children:"workflow.ExecuteActivity()"}),".\nHowever, this is not necessary. If you want to execute multiple activities in parallel, you can\nrepeatedly call ",(0,c.jsx)(t.code,{children:"workflow.ExecuteActivity()"}),", store the returned futures, and then wait for all\nactivities to complete by calling the ",(0,c.jsx)(t.code,{children:"Get()"})," methods of the future at a later time."]}),"\n",(0,c.jsxs)(t.p,{children:["To implement more complex wait conditions on returned future objects, use the ",(0,c.jsx)(t.code,{children:"cadence.Selector"})," class."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>s});var n=i(6540);const c={},o=n.createContext(c);function a(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);