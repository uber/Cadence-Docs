"use strict";(self.webpackChunkcadence=self.webpackChunkcadence||[]).push([[9609],{5519:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"java-client/retries","title":"Retries","description":"Activitiesworkflow can fail due to various intermediate conditions. In those cases, we want","source":"@site/docs/04-java-client/12-retries.md","sourceDirName":"04-java-client","slug":"/java-client/retries","permalink":"/docs/java-client/retries","draft":false,"unlisted":false,"editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/docs/04-java-client/12-retries.md","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"layout":"default","title":"Retries","permalink":"/docs/java-client/retries"},"sidebar":"docsSidebar","previous":{"title":"Queries","permalink":"/docs/java-client/queries"},"next":{"title":"Child workflows","permalink":"/docs/java-client/child-workflows"}}');var o=i(4848),r=i(8453);const s={layout:"default",title:"Retries",permalink:"/docs/java-client/retries"},l="Activity and workflow retries",a={},c=[{value:"RetryOptions",id:"retryoptions",level:2},{value:"InitialInterval",id:"initialinterval",level:3},{value:"BackoffCoefficient",id:"backoffcoefficient",level:3},{value:"MaximumInterval",id:"maximuminterval",level:3},{value:"ExpirationInterval",id:"expirationinterval",level:3},{value:"MaximumAttempts",id:"maximumattempts",level:3},{value:"NonRetriableErrorReasons(via setDoNotRetry)",id:"nonretriableerrorreasonsvia-setdonotretry",level:3},{value:"Activity Timeout Usage",id:"activity-timeout-usage",level:2},{value:"Activity Timeout Internals",id:"activity-timeout-internals",level:2},{value:"Basics without Retry",id:"basics-without-retry",level:3},{value:"Heartbeat timeout",id:"heartbeat-timeout",level:3},{value:"RetryOptions and Activity with Retry",id:"retryoptions-and-activity-with-retry",level:3}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"activity-and-workflow-retries",children:"Activity and workflow retries"})}),"\n",(0,o.jsxs)(t.p,{children:["Activities and workflows can fail due to various intermediate conditions. In those cases, we want\nto retry the failed activity or child workflow or even the parent workflow. This can be achieved\nby supplying an optional ",(0,o.jsx)(t.a,{href:"https://www.javadoc.io/static/com.uber.cadence/cadence-client/2.7.9-alpha/com/cadence-workflow/cadence/common/RetryOptions.Builder.html#setInitialInterval-java.time.Duration-",children:"retry options"}),"."]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Note that sometimes it's also referred as RetryPolicy"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"retryoptions",children:"RetryOptions"}),"\n",(0,o.jsx)(t.p,{children:"A RetryOptions includes the following."}),"\n",(0,o.jsx)(t.h3,{id:"initialinterval",children:"InitialInterval"}),"\n",(0,o.jsx)(t.p,{children:"Backoff interval for the first retry. If coefficient is 1.0 then it is used for all retries.\nRequired, no default value."}),"\n",(0,o.jsx)(t.h3,{id:"backoffcoefficient",children:"BackoffCoefficient"}),"\n",(0,o.jsx)(t.p,{children:"Coefficient used to calculate the next retry backoff interval.\nThe next retry interval is previous interval multiplied by this coefficient.\nMust be 1 or larger. Default is 2.0."}),"\n",(0,o.jsx)(t.h3,{id:"maximuminterval",children:"MaximumInterval"}),"\n",(0,o.jsx)(t.p,{children:"Maximum backoff interval between retries. Exponential backoff leads to interval increase.\nThis value is the cap of the interval. Default is 100x of initial interval."}),"\n",(0,o.jsx)(t.h3,{id:"expirationinterval",children:"ExpirationInterval"}),"\n",(0,o.jsx)(t.p,{children:"Maximum time to retry. Either ExpirationInterval or MaximumAttempts is required.\nWhen exceeded the retries stop even if maximum retries is not reached yet.\nFirst (non-retry) attempt is unaffected by this field and is guaranteed to run\nfor the entirety of the workflow timeout duration (ExecutionStartToCloseTimeoutSeconds)."}),"\n",(0,o.jsx)(t.h3,{id:"maximumattempts",children:"MaximumAttempts"}),"\n",(0,o.jsx)(t.p,{children:"Maximum number of attempts. When exceeded the retries stop even if not expired yet.\nIf not set or set to 0, it means unlimited, and relies on ExpirationInterval to stop.\nEither MaximumAttempts or ExpirationInterval is required."}),"\n",(0,o.jsx)(t.h3,{id:"nonretriableerrorreasonsvia-setdonotretry",children:"NonRetriableErrorReasons(via setDoNotRetry)"}),"\n",(0,o.jsx)(t.p,{children:"Non-Retriable errors. This is optional. Cadence server will stop retry if error reason matches this list.\nWhen matching an exact match is used. So adding RuntimeException.class to this list is going to include only RuntimeException itself, not all of its subclasses. The reason for such behaviour is to be able to support server side retries without knowledge of Java exception hierarchy. When considering an exception type a cause of ActivityFailureException and ChildWorkflowFailureException is looked at.\nError and CancellationException are never retried and are not even passed to this filter."}),"\n",(0,o.jsx)(t.h2,{id:"activity-timeout-usage",children:"Activity Timeout Usage"}),"\n",(0,o.jsx)(t.p,{children:"It's probably too complicated to learn how to set those timeouts by reading the above. There is an easy way to deal with it."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"LocalActivity without retry"}),": Use ScheduleToClose for overall timeout"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Regular Activity without retry"}),":"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Use ScheduleToClose for overall timeout"}),"\n",(0,o.jsx)(t.li,{children:"Leave ScheduleToStart and StartToClose empty"}),"\n",(0,o.jsx)(t.li,{children:"If ScheduleToClose is too large(like 10 mins), then set Heartbeat timeout to a smaller value like 10s. Call heartbeat API inside activity regularly."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"LocalActivity with retry"}),":"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Use ScheduleToClose as timeout of each attempt."}),"\n",(0,o.jsx)(t.li,{children:"Use retryOptions.InitialInterval, retryOptions.BackoffCoefficient, retryOptions.MaximumInterval to control backoff."}),"\n",(0,o.jsx)(t.li,{children:"Use retryOptions.ExperiationInterval as overall timeout of all attempts."}),"\n",(0,o.jsx)(t.li,{children:"Leave retryOptions.MaximumAttempts empty."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Regular Activity with retry"}),":"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Use ScheduleToClose as timeout of each attempt"}),"\n",(0,o.jsx)(t.li,{children:"Leave ScheduleToStart and StartToClose empty"}),"\n",(0,o.jsx)(t.li,{children:"If ScheduleToClose is too large(like 10 mins), then set Heartbeat timeout to a smaller value like 10s. Call heartbeat API inside activity regularly."}),"\n",(0,o.jsx)(t.li,{children:"Use retryOptions.InitialInterval, retryOptions.BackoffCoefficient, retryOptions.MaximumInterval to control backoff."}),"\n",(0,o.jsx)(t.li,{children:"Use retryOptions.ExperiationInterval as overall timeout of all attempts."}),"\n",(0,o.jsx)(t.li,{children:"Leave retryOptions.MaximumAttempts empty."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"activity-timeout-internals",children:"Activity Timeout Internals"}),"\n",(0,o.jsx)(t.h3,{id:"basics-without-retry",children:"Basics without Retry"}),"\n",(0,o.jsx)(t.p,{children:"Things are easier to understand in the world without retry. Because Cadence started from it."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"ScheduleToClose timeout is the overall end-to-end timeout from a workflow's perspective."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"ScheduleToStart timeout is the time that activity worker needed to start an activity. Exceeding this timeout, activity will return an ScheduleToStart timeout error/exception to workflow"}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"StartToClose timeout is the time that an activity needed to run. Exceeding this will return\nStartToClose to workflow."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Requirement and defaults:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Either ScheduleToClose is provided or both of ScheduleToStart and StartToClose are provided."}),"\n",(0,o.jsx)(t.li,{children:"If only ScheduleToClose, then ScheduleToStart and StartToClose are default to it."}),"\n",(0,o.jsxs)(t.li,{children:["If only ScheduleToStart and StartToClose are provided, then ",(0,o.jsx)(t.code,{children:"ScheduleToClose = ScheduleToStart + StartToClose"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["All of them are capped by workflowTimeout. (e.g. if workflowTimeout is 1hour, set 2 hour for ScheduleToClose will still get 1 hour :",(0,o.jsx)(t.code,{children:"ScheduleToClose=Min(ScheduleToClose, workflowTimeout)"})," )"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"So why are they?"})}),"\n",(0,o.jsxs)(t.p,{children:["You may notice that ScheduleToClose is only useful when\n",(0,o.jsx)(t.code,{children:"ScheduleToClose < ScheduleToStart + StartToClose"}),". Because if ",(0,o.jsx)(t.code,{children:"ScheduleToClose >= ScheduleToStart+StartToClose"})," the ScheduleToClose timeout is already enforced by the combination of the other two, and it become meaningless."]}),"\n",(0,o.jsxs)(t.p,{children:["So the main use case of ScheduleToClose being less than the sum of two is that people want to limit the overall timeout of the activity but give more timeout for scheduleToStart or startToClose. ",(0,o.jsx)(t.strong,{children:"This is extremely rare use case"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Also the main use case that people want to distinguish ScheduleToStart and StartToClose is that the workflow may need to do some special handling for ScheduleToStart timeout error. ",(0,o.jsx)(t.strong,{children:"This is also very rare use case"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Therefore, you can understand why in TL;DR that I recommend only using ",(0,o.jsx)(t.strong,{children:"ScheduleToClose"})," but leave the other two empty. Because only in some rare cases you may need it. If you can't think of the use case, then you do not need it."]}),"\n",(0,o.jsx)(t.p,{children:"LocalActivity doesn't have ScheduleToStart/StartToClose because it's started directly inside workflow worker without server scheduling involved."}),"\n",(0,o.jsx)(t.h3,{id:"heartbeat-timeout",children:"Heartbeat timeout"}),"\n",(0,o.jsxs)(t.p,{children:["Heartbeat is very important for long running activity, to prevent it from getting stuck. Not only bugs can cause activity getting stuck, regular deployment/host restart/failure could also cause it. Because without heartbeat, Cadence server couldn't know whether or not the activity is still being worked on. See more details about here ",(0,o.jsx)(t.a,{href:"https://stackoverflow.com/questions/65118584/solutions-to-stuck-timers-activities-in-cadence-swf-stepfunctions/65118585#65118585",children:"https://stackoverflow.com/questions/65118584/solutions-to-stuck-timers-activities-in-cadence-swf-stepfunctions/65118585#65118585"})]}),"\n",(0,o.jsx)(t.h3,{id:"retryoptions-and-activity-with-retry",children:"RetryOptions and Activity with Retry"}),"\n",(0,o.jsxs)(t.p,{children:["First of all, here RetryOptions is for ",(0,o.jsx)(t.code,{children:"server side"})," backoff retry -- meaning that the retry is managed automatically by Cadence without interacting with workflows. Because retry is managed by Cadence, the activity has to be specially handled in Cadence history that the started event can not written until the activity is closed. Here is some reference: ",(0,o.jsx)(t.a,{href:"https://stackoverflow.com/questions/65113363/why-an-activity-task-is-scheduled-but-not-started/65113365#65113365",children:"https://stackoverflow.com/questions/65113363/why-an-activity-task-is-scheduled-but-not-started/65113365#65113365"})]}),"\n",(0,o.jsxs)(t.p,{children:["In fact, workflow can do ",(0,o.jsx)(t.code,{children:"client side"})," retry on their own. This means workflow will be managing the retry logic. You can write your own retry function, or there is some helper function in SDK,  like ",(0,o.jsx)(t.code,{children:"Workflow.retry"})," in Cadence-java-client. Client side retry will show all start events immediately, but there will be many events in the history when retrying for a single activity. It's not recommended because of performance issue."]}),"\n",(0,o.jsx)(t.p,{children:"So what do the options mean:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"ExpirationInterval:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"It replaces the ScheduleToClose timeout to become the actual overall timeout of the activity for all attempts."}),"\n",(0,o.jsxs)(t.li,{children:["It's also capped to workflow timeout like other three timeout options. ",(0,o.jsx)(t.code,{children:"ScheduleToClose = Min(ScheduleToClose, workflowTimeout)"})]}),"\n",(0,o.jsx)(t.li,{children:"The timeout of each attempt is StartToClose, but StartToClose defaults to ScheduleToClose like explanation above."}),"\n",(0,o.jsxs)(t.li,{children:["ScheduleToClose will be extended to ExpirationInterval:\n",(0,o.jsx)(t.code,{children:"ScheduleToClose = Max(ScheduleToClose, ExpirationInterval)"}),", and this happens before ScheduleToClose is copied to ScheduleToClose and StartToClose."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"InitialInterval: the interval of first retry"}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"BackoffCoefficient: self explained"}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"MaximumInterval: maximum of the interval during retry"}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"MaximumAttempts: the maximum attempts. If existing with ExpirationInterval, then retry stops when either one of them is exceeded."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Requirements and defaults"}),":"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Either MaximumAttempts or ExpirationInterval is required. ExpirationInterval is set to workflowTimeout if not provided."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Since ExpirationInterval is always there, and in fact it's more useful. And I think it's quite confusing to use MaximumAttempts, so I would recommend just use ExpirationInterval. Unless you really need it."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>l});var n=i(6540);const o={},r=n.createContext(o);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);