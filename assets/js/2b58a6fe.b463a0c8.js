"use strict";(self.webpackChunkcadence=self.webpackChunkcadence||[]).push([[3190],{5490:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"go-client/workers","title":"Worker service","description":"A or service is a service that hosts the and implementations. The polls the Cadence service fortaskstask, and communicates execution results back to the Cadence service.Worker: services are developed, deployed, and operated by Cadence customers.","source":"@site/docs/05-go-client/01-workers.md","sourceDirName":"05-go-client","slug":"/go-client/workers","permalink":"/docs/go-client/workers","draft":false,"unlisted":false,"editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/docs/05-go-client/01-workers.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"layout":"default","title":"Worker service","permalink":"/docs/go-client/workers"},"sidebar":"docsSidebar","previous":{"title":"Introduction","permalink":"/docs/go-client/"},"next":{"title":"Creating workflows","permalink":"/docs/go-client/create-workflows"}}');var t=r(4848),i=r(8453);const a={layout:"default",title:"Worker service",permalink:"/docs/go-client/workers"},c="Worker service",s={},l=[];function d(e){const n={code:"code",em:"em",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"worker-service",children:"Worker service"})}),"\n",(0,t.jsxs)(n.p,{children:["A worker or ",(0,t.jsx)(n.em,{children:"worker service"})," is a service that hosts the workflow and activity implementations. The worker polls the ",(0,t.jsx)(n.em,{children:"Cadence service"})," for tasks, performs those tasks, and communicates task execution results back to the ",(0,t.jsx)(n.em,{children:"Cadence service"}),". Worker services are developed, deployed, and operated by Cadence customers."]}),"\n",(0,t.jsx)(n.p,{children:"You can run a Cadence worker in a new or an existing service. Use the framework APIs to start the Cadence worker and link in all activity and workflow implementations that you require the service to execute."}),"\n",(0,t.jsx)(n.p,{children:"The following is an example worker service utilising tchannel, one of the two transport protocols supported by Cadence."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n\n    "go.uber.org/cadence/.gen/go/cadence"\n    "go.uber.org/cadence/.gen/go/cadence/workflowserviceclient"\n    "go.uber.org/cadence/worker"\n\n    "github.com/uber-go/tally"\n    "go.uber.org/zap"\n    "go.uber.org/zap/zapcore"\n    "go.uber.org/yarpc"\n    "go.uber.org/yarpc/api/transport"\n    "go.uber.org/yarpc/transport/tchannel"\n)\n\nvar HostPort = "127.0.0.1:7933"\nvar Domain = "SimpleDomain"\nvar TaskListName = "SimpleWorker"\nvar ClientName = "SimpleWorker"\nvar CadenceService = "cadence-frontend"\n\nfunc main() {\n    startWorker(buildLogger(), buildCadenceClient())\n}\n\nfunc buildLogger() *zap.Logger {\n    config := zap.NewDevelopmentConfig()\n    config.Level.SetLevel(zapcore.InfoLevel)\n\n    var err error\n    logger, err := config.Build()\n    if err != nil {\n        panic("Failed to setup logger")\n    }\n\n    return logger\n}\n\nfunc buildCadenceClient() workflowserviceclient.Interface {\n    ch, err := tchannel.NewChannelTransport(tchannel.ServiceName(ClientName))\n    if err != nil {\n        panic("Failed to setup tchannel")\n    }\n    dispatcher := yarpc.NewDispatcher(yarpc.Config{\n        Name: ClientName,\n        Outbounds: yarpc.Outbounds{\n            CadenceService: {Unary: ch.NewSingleOutbound(HostPort)},\n        },\n    })\n    if err := dispatcher.Start(); err != nil {\n        panic("Failed to start dispatcher")\n    }\n\n    return workflowserviceclient.New(dispatcher.ClientConfig(CadenceService))\n}\n\nfunc startWorker(logger *zap.Logger, service workflowserviceclient.Interface) {\n    // TaskListName identifies set of client workflows, activities, and workers.\n    // It could be your group or client or application name.\n    workerOptions := worker.Options{\n        Logger:       logger,\n        MetricsScope: tally.NewTestScope(TaskListName, map[string]string{}),\n    }\n\n    worker := worker.New(\n        service,\n        Domain,\n        TaskListName,\n        workerOptions)\n    err := worker.Start()\n    if err != nil {\n        panic("Failed to start worker")\n    }\n\n    logger.Info("Started Worker.", zap.String("worker", TaskListName))\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The other supported transport protocol is gRPC. A worker service using gRPC can be set up in similar fashion, but the ",(0,t.jsx)(n.code,{children:"buildCadenceClient"})," function will need the following alterations, and some of the imported packages need to change."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'\nimport (\n\n    "go.uber.org/cadence/.gen/go/cadence"\n    "go.uber.org/cadence/.gen/go/cadence/workflowserviceclient"\n    "go.uber.org/cadence/compatibility"\n    "go.uber.org/cadence/worker"\n\n    apiv1 "github.com/cadence-workflow/cadence-idl/go/proto/api/v1"\n    "github.com/uber-go/tally"\n    "go.uber.org/zap"\n    "go.uber.org/zap/zapcore"\n    "go.uber.org/yarpc"\n    "go.uber.org/yarpc/transport/grpc"\n)\n\n.\n.\n.\n\nfunc buildCadenceClient() workflowserviceclient.Interface {\n\n    dispatcher := yarpc.NewDispatcher(yarpc.Config{\n      Name: ClientName,\n      Outbounds: yarpc.Outbounds{\n        CadenceService: {Unary: grpc.NewTransport().NewSingleOutbound(HostPort)},\n      },\n    })\n    if err := dispatcher.Start(); err != nil {\n      panic("Failed to start dispatcher")\n    }\n\n    clientConfig := dispatcher.ClientConfig(CadenceService)\n\n    return compatibility.NewThrift2ProtoAdapter(\n      apiv1.NewDomainAPIYARPCClient(clientConfig),\n      apiv1.NewWorkflowAPIYARPCClient(clientConfig),\n      apiv1.NewWorkerAPIYARPCClient(clientConfig),\n      apiv1.NewVisibilityAPIYARPCClient(clientConfig),\n    )\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Note also that the ",(0,t.jsx)(n.code,{children:"HostPort"})," variable must be changed to target the gRPC listener port of the Cadence cluster (typically, 7833)."]}),"\n",(0,t.jsxs)(n.p,{children:["Finally, gRPC can also support TLS connections between Go clients and the Cadence server. This requires the following alterations to the imported packages, and the ",(0,t.jsx)(n.code,{children:"buildCadenceClient"})," function. Note that this also requires you replace ",(0,t.jsx)(n.code,{children:'"path/to/cert/file"'})," in the function with a path to a valid certificate file matching the TLS configuration of the Cadence server."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'\nimport (\n\n    "fmt"\n\n    "go.uber.org/cadence/.gen/go/cadence"\n    "go.uber.org/cadence/.gen/go/cadence/workflowserviceclient"\n    "go.uber.org/cadence/compatibility"\n    "go.uber.org/cadence/worker"\n\n    apiv1 "github.com/cadence-workflow/cadence-idl/go/proto/api/v1"\n    "github.com/uber-go/tally"\n    "go.uber.org/zap"\n    "go.uber.org/zap/zapcore"\n    "go.uber.org/yarpc"\n    "go.uber.org/yarpc/transport/grpc"\n    "go.uber.org/yarpc/peer"\n    "go.uber.org/yarpc/peer/hostport"\n\n    "crypto/tls"\n    "crypto/x509"\n    "io/ioutil"\n\n    "google.golang.org/grpc/credentials"\n)\n\n.\n.\n.\n\nfunc buildCadenceClient() workflowserviceclient.Interface {\n     grpcTransport := grpc.NewTransport()\n     var dialOptions []grpc.DialOption\n\n     caCert, err := ioutil.ReadFile("/path/to/cert/file")\n     if err != nil {\n          fmt.Printf("Failed to load server CA certificate: %v", zap.Error(err))\n     }\n\n     caCertPool := x509.NewCertPool()\n     if !caCertPool.AppendCertsFromPEM(caCert) {\n          fmt.Errorf("Failed to add server CA\'s certificate")\n     }\n\n     tlsConfig := tls.Config{\n          RootCAs: caCertPool,\n     }\n\n     creds := credentials.NewTLS(&tlsConfig)\n     dialOptions = append(dialOptions, grpc.DialerCredentials(creds))\n\n     dialer := grpcTransport.NewDialer(dialOptions...)\n     outbound := grpcTransport.NewOutbound(\n                        peer.NewSingle(hostport.PeerIdentifier(HostPort), dialer)\n                 )\n\n     dispatcher := yarpc.NewDispatcher(yarpc.Config{\n          Name: ClientName,\n          Outbounds: yarpc.Outbounds{\n               CadenceService: {Unary: outbound},\n          },\n     })\n     if err := dispatcher.Start(); err != nil {\n          panic("Failed to start dispatcher")\n     }\n\n     clientConfig := dispatcher.ClientConfig(CadenceService)\n\n     return compatibility.NewThrift2ProtoAdapter(\n          apiv1.NewDomainAPIYARPCClient(clientConfig),\n          apiv1.NewWorkflowAPIYARPCClient(clientConfig),\n          apiv1.NewWorkerAPIYARPCClient(clientConfig),\n          apiv1.NewVisibilityAPIYARPCClient(clientConfig),\n     )\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var o=r(6540);const t={},i=o.createContext(t);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);